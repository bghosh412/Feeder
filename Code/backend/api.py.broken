import gc
import time
from microdot import Microdot, Response
import services
import last_fed_service
import quantity_service
import next_feed_service

gc.collect()

# Track server start time for uptime calculation
SERVER_START_TIME = time.time()

# Initialize Microdot app
app = Microdot()

# =============================================================================
# CORS Middleware - after_request handler adds CORS headers to all responses
# =============================================================================
@app.after_request
def add_cors_headers(request, response):
    """Add CORS headers to all responses."""
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, DELETE, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response

# =============================================================================
# OPTIONS handler for preflight requests
# =============================================================================
@app.route('/<path:path>', methods=['OPTIONS'])
def handle_options(request, path):
    """Handle OPTIONS preflight requests."""
    return '', 200

# =============================================================================
# Feed Endpoints
# =============================================================================
@app.route('/api/feednow', methods=['POST'])
@app.route('/api/feed', methods=['POST'])
def api_feed(request):
    """Manual feeding endpoint - supports both /api/feednow and /api/feed."""
    import lib.notification
    import calibration_service
    import event_log_service
    
    # Log manual feed event
    event_log_service.log_event(event_log_service.EVENT_FEED_MANUAL, 'Manual feed via web interface')
    
    # Disburse food using calibrated servo settings
    food_dispensed = calibration_service.disburseFood()
    
    if food_dispensed:
        # Update quantity and last fed timestamp
        quantity = quantity_service.read_quantity()
        if quantity > 0:
            quantity -= 1
        quantity_service.write_quantity(quantity)
        last_fed_service.write_last_fed_now()
        
        # Free memory before sending notification
        gc.collect()
        
        # Send notification
        now = time.localtime()
        msg = "Food disbursed at {:02d}:{:02d}:{:02d}. Feed remaining: {}".format(now[3], now[4], now[5], quantity)
        lib.notification.send_ntfy_notification(msg)
        
        return {'status': 'ok', 'quantity': quantity}, 200
    else:
        # Food dispensing failed
        return {'status': 'error', 'message': 'Failed to dispense food'}, 500

# =============================================================================
# Quantity Endpoints
# =============================================================================
@app.get('/api/quantity')
def api_get_quantity(request):
    """Get current food quantity."""
    quantity = quantity_service.read_quantity()
    return {'quantity': quantity}, 200

@app.post('/api/quantity')
def api_set_quantity(request):
    """Update food quantity."""
    import lib.notification
    import event_log_service
    
    data = request.json
    if data is None:
        return {'error': 'Invalid JSON'}, 400
    
    value = data.get('quantity')
    if value is not None:
        quantity_service.write_quantity(value)
        
        # Log quantity update
        event_log_service.log_event(event_log_service.EVENT_QUANTITY_UPDATE, 'Updated to {}'.format(value))
        
        # Free memory before sending notification
        gc.collect()
        
        msg = "Remaining food quantity updated to {}".format(value)
        lib.notification.send_ntfy_notification(msg)
        return {'status': 'ok'}, 200
    else:
        return {'error': 'Missing quantity'}, 400

# =============================================================================
# Schedule Endpoints
# =============================================================================
@app.get('/api/schedule')
@app.get('/api/schedules')
def api_get_schedule(request):
    """Get feeding schedule."""
    data = services.read_schedule()
    if data:
        return data, 200
    else:
        return {'error': 'Could not read schedule'}, 500

@app.post('/api/schedule')
def api_set_schedule(request):
    """Update feeding schedule."""
    import event_log_service
    
    data = request.json
    if data is None:
        return {'error': 'Invalid JSON'}, 400
    
    print('Received schedule data:', data)
    result = services.write_schedule(data)
    if result:
        # Log schedule change
        event_log_service.log_event(event_log_service.EVENT_CONFIG_CHANGE, 'Schedule updated')
        return {'status': 'ok'}, 200
    else:
        print('Failed to write schedule')
        return {'error': 'Failed to save schedule'}, 500

@app.route('/api/schedule/<path:id>', methods=['DELETE'])
def api_delete_schedule(request, id):
    """Delete a schedule (placeholder for future implementation)."""
    # For now, just return success - implement delete logic as needed
    return {'status': 'ok', 'message': 'Schedule deleted'}, 200

# =============================================================================
# Home/Status Endpoints
# =============================================================================
@app.get('/api/home')
def api_home(request):
    """Get home dashboard data."""
    quantity = quantity_service.read_quantity()
    last_fed = last_fed_service.read_last_fed()
    next_feed = next_feed_service.read_next_feed()
    return {
        'connectionStatus': 'Online',
        'feedRemaining': '{} more feed remaining'.format(quantity),
        'lastFed': last_fed,
        'batteryStatus': '40% of the Battery remaining',
        'nextFeed': next_feed
    }, 200

@app.get('/api/ping')
@app.get('/api/status')
def api_ping(request):
    """Health check endpoint."""
    return {'status': 'ok', 'message': 'Server is running'}, 200

# =============================================================================
# Last Fed Endpoints
# =============================================================================
@app.get('/api/lastfed')
def api_get_lastfed(request):
    """Get last fed timestamp."""
    last_fed = last_fed_service.read_last_fed()
    if last_fed:
        return {'last_fed_time': last_fed}, 200
    else:
        return {'error': 'Could not read'}, 500

@app.post('/api/lastfed')
def api_set_lastfed(request):
    """Update last fed timestamp."""
    data = request.json
    if data is None:
        return {'error': 'Invalid JSON'}, 400
    
    last_fed_time = data.get('last_fed_time')
    if last_fed_time:
        with open(last_fed_service.data_file, 'w') as f:
            f.write(last_fed_time)
        return {'status': 'ok'}, 200
    else:
        return {'error': 'Missing last_fed_time'}, 400

# =============================================================================
# Calibration Endpoints
# =============================================================================
@app.get('/api/calibration')
@app.get('/api/calibration/get')
def api_get_calibration(request):
    """Get current calibration settings."""
    try:
        import calibration_service
        data = calibration_service.get_current_calibration()
        return data, 200
    except Exception as e:
        print('Error reading calibration:', e)
        return {'error': str(e)}, 500

@app.post('/api/calibration/save')
def api_save_calibration(request):
    """Save calibration settings."""
    try:
        import calibration_service
        
        data = request.json
        if data is None:
            return {'error': 'Invalid JSON'}, 400
        
        duty_cycle = data.get('duty_cycle')
        pulse_duration = data.get('pulse_duration')
        
        if duty_cycle is not None and pulse_duration is not None:
            success = calibration_service.save_calibration(duty_cycle, pulse_duration)
            if success:
                return {'status': 'ok', 'duty_cycle': duty_cycle, 'pulse_duration': pulse_duration}, 200
            else:
                return {'error': 'Failed to save'}, 500
        else:
            return {'error': 'Missing parameters'}, 400
    except Exception as e:
        print('Error saving calibration:', e)
        return {'error': str(e)}, 500

@app.post('/api/calibration/adjust_duty')
def api_adjust_duty(request):
    """Adjust duty cycle."""
    try:
        import calibration_service
        
        data = request.json
        if data is None:
            data = {}
        
        increment = data.get('increment', 1)
        duty_cycle, pulse_duration = calibration_service.adjust_duty_cycle(increment)
        return {'status': 'ok', 'duty_cycle': duty_cycle, 'pulse_duration': pulse_duration}, 200
    except Exception as e:
        print('Error adjusting duty cycle:', e)
        return {'error': str(e)}, 500

@app.post('/api/calibration/adjust_duration')
def api_adjust_duration(request):
    """Adjust pulse duration."""
    try:
        import calibration_service
        
        data = request.json
        if data is None:
            data = {}
        
        increment = data.get('increment', 5)
        duty_cycle, pulse_duration = calibration_service.adjust_pulse_duration(increment)
        return {'status': 'ok', 'duty_cycle': duty_cycle, 'pulse_duration': pulse_duration}, 200
    except Exception as e:
        print('Error adjusting pulse duration:', e)
        return {'error': str(e)}, 500

@app.post('/api/calibration/test')
def api_test_calibration(request):
    """Test current calibration."""
    try:
        import calibration_service
        result = calibration_service.test_calibration()
        return result, 200
    except Exception as e:
        print('Error testing calibration:', e)
        return {'error': str(e)}, 500

@app.post('/api/calibrate/left')
@app.post('/api/calibrate/right')
def api_calibrate_motor(request):
    """Calibrate motor movement."""
    try:
        # Check if running on actual hardware (ESP8266/ESP32)
        try:
            from machine import Pin
            on_hardware = True
        except ImportError:
            on_hardware = False
            print('Warning: Not running on ESP hardware, motor control disabled')
        
        if on_hardware:
            import config
            from lib.stepper import StepperMotor
            
            # Get data from request
            data = request.json
            if data is None:
                data = {}
            
            # Get speed from request
            speed = data.get('speed', 'medium')
            
            # Map speed to delay_ms (lower delay = faster)
            speed_map = {
                'very_slow': 10,
                'slow': 5,
                'medium': 2,
                'fast': 1,
                'very_fast': 0
            }
            delay_ms = speed_map.get(speed, 2)
            
            # Initialize motor
            motor = StepperMotor(
                config.MOTOR_PIN_1,
                config.MOTOR_PIN_2,
                config.MOTOR_PIN_3,
                config.MOTOR_PIN_4
            )
            
            # Determine direction and steps
            # 512 steps = 1/8 rotation (about 45 degrees)
            steps = 512
            if request.path == '/api/calibrate/left':
                steps = -steps  # Negative for counter-clockwise
            
            print('Calibrating motor: {} steps at {} ms delay'.format(steps, delay_ms))
            motor.step(steps, delay_ms)
            motor.off()  # Turn off motor to save power
            
            direction = 'left' if request.path == '/api/calibrate/left' else 'right'
            return {'status': 'ok', 'message': 'Motor moved {}'.format(direction)}, 200
        else:
            # Simulation mode - just return success without moving motor
            direction = 'left' if request.path == '/api/calibrate/left' else 'right'
            data = request.json if request.json else {}
            speed = data.get('speed', 'medium')
            print('Simulation: Would move motor {} at {} speed'.format(direction, speed))
            return {'status': 'ok', 'message': 'Motor moved {} (simulation mode)'.format(direction)}, 200
    except Exception as e:
        print('Error in calibration:', e)
        error_msg = 'Calibration error: {}'.format(str(e))
        return {'status': 'error', 'message': error_msg}, 500

# =============================================================================
# Event Log Endpoints
# =============================================================================
@app.get('/api/events')
def api_get_events(request):
    """Get event log."""
    try:
        import event_log_service
        limit = 100  # Default to all events
        events = event_log_service.read_events(limit)
        return {'events': events}, 200
    except Exception as e:
        print('Error reading events:', e)
        return {'error': str(e)}, 500

# =============================================================================
# System Info Endpoints
# =============================================================================
@app.get('/api/system/memory')
def api_system_memory(request):
    """Get free memory."""
    try:
        gc.collect()
        free_mem = gc.mem_free()
        return {'free_memory': free_mem}, 200
    except Exception as e:
        print('Error reading memory:', e)
        return {'error': str(e)}, 500

@app.get('/api/system/uptime')
def api_system_uptime(request):
    """Get server uptime."""
    try:
        uptime_seconds = int(time.time() - SERVER_START_TIME)
        return {'uptime': uptime_seconds}, 200
    except Exception as e:
        print('Error reading uptime:', e)
        return {'error': str(e)}, 500

# =============================================================================
# Config Endpoints
# =============================================================================
@app.get('/api/config')
def api_get_config(request):
    """Get configuration settings."""
    try:
        import config
        result = {
            'ntfy_topic': config.NTFY_TOPIC if hasattr(config, 'NTFY_TOPIC') else 'N/A',
            'ntfy_server': config.NTFY_SERVER if hasattr(config, 'NTFY_SERVER') else 'N/A'
        }
        return result, 200
    except Exception as e:
        print('Error reading config:', e)
        return {'error': str(e)}, 500

# =============================================================================
# Static File Serving
# =============================================================================
@app.get('/')
@app.get('/index.html')
def serve_index(request):
    """Serve the main index page."""
    return send_file_chunked('UI/index.html', 'text/html', no_cache=True)

@app.get('/<path:filepath>')
def serve_static(request, filepath):
    """Serve static files from UI directory."""
    file_path = 'UI/' + filepath
    
    # Determine content type
    content_type = 'text/html'
    if filepath.endswith('.css'):
        content_type = 'text/css'
    elif filepath.endswith('.js'):
        content_type = 'application/javascript'
    elif filepath.endswith('.png'):
        content_type = 'image/png'
    elif filepath.endswith('.jpg') or filepath.endswith('.jpeg'):
        content_type = 'image/jpeg'
    
    # Determine caching policy
    is_image = content_type.startswith('image/')
    
    try:
        return send_file_chunked(file_path, content_type, no_cache=not is_image)
    except:
        return 'Not Found', 404

def send_file_chunked(file_path, content_type, no_cache=False):
    """
    Send a file in chunks to avoid memory issues.
    This is a custom implementation since Microdot's send_file() may load entire file.
    """
    try:
        import os
        file_size = os.stat(file_path)[6]
        
        def file_generator():
            with open(file_path, 'rb') as f:
                while True:
                    chunk = f.read(512)
                    if not chunk:
                        break
                    yield chunk
                    gc.collect()
        
        # Build headers
        headers = {'Content-Type': content_type}
        
        if no_cache:
            # No cache for HTML, CSS, JS files
            headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
            headers['Pragma'] = 'no-cache'
            headers['Expires'] = '0'
        else:
            # Cache images for 1 week
            headers['Cache-Control'] = 'public, max-age=604800'
            headers['Expires'] = 'Thu, 31 Dec 2026 23:59:59 GMT'
        
        return Response(file_generator(), headers=headers)
    except Exception as e:
        print('Error serving file {}: {}'.format(file_path, e))
        raise

# =============================================================================
# Startup Notification
# =============================================================================
def send_startup_notification(ip, port):
    """Send startup notification."""
    try:
        import lib.notification
        url = 'http://{}:{}'.format(ip, port)
        now = time.localtime()
        time_str = "{:02d}:{:02d}:{:02d}".format(now[3], now[4], now[5])
        msg = 'Feeder started at {} and can be accessed at {}'.format(time_str, url)
        lib.notification.send_ntfy_notification(msg)
        print('Startup notification sent:', msg)
    except Exception as e:
        print('Could not send startup notification:', e)

def get_ip():
    """Get actual IP address."""
    try:
        import network
        sta = network.WLAN(network.STA_IF)
        if sta.isconnected():
            return sta.ifconfig()[0]
    except:
        pass
    return '0.0.0.0'

# =============================================================================
# Main Entry Point
# =============================================================================
if __name__ == '__main__':
    # Get actual IP
    ip = get_ip()
    port = 5000
    
    print('Starting Feeder API server on {}:{}'.format(ip, port))
    
    # Send startup notification
    send_startup_notification(ip, port)
    
    # Start server (Microdot automatically handles async if available)
    app.run(host='0.0.0.0', port=port, debug=False)
